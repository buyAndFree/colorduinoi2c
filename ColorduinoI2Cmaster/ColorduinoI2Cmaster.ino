/*
  Arduino I2C to Colorduino Demo

  Patched to work with updated Colourduino I2C Sketch
  Compiles properly now on latest Aruino IDE (using new Wire library)
   
  based on 
  -arduino firmware by michael vogt <michu@neophob.com>
  -blinkm firmware by thingM
  -"daft punk" firmware by Scott C / ThreeFN 
   
  This DEMO is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.
  This DEMO is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <Wire.h>
#include <avr/pgmspace.h> 

#define START_OF_DATA 0x10       //data markers
#define END_OF_DATA 0x20         //data markers
#define DEST_I2C_ADDR 0x05          //set destination I2C address (must match firmware in Colorduino module)

#define SCREENSIZEX 8            //num of LEDs accross
#define SCREENSIZEY 8            //num of LEDs down

byte display_byte[3][64];        //display array - 64 bytes x 3 colours 

const unsigned char font8_8[92][8] PROGMEM =                                 
{                                                            
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   // sp          
    { 0x00, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00 },   // !           
    { 0x00, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00 },   // "           
    { 0x00, 0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14, 0x00 },   // #           
    { 0x00, 0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12, 0x00 },   // $           
    { 0x00, 0x00, 0x62, 0x64, 0x08, 0x13, 0x23, 0x00 },   // %           
    { 0x00, 0x00, 0x36, 0x49, 0x55, 0x22, 0x50, 0x00 },   // &           
    { 0x00, 0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00 },   // '           
    { 0x00, 0x00, 0x00, 0x1c, 0x22, 0x41, 0x00, 0x00 },   // (           
    { 0x00, 0x00, 0x00, 0x41, 0x22, 0x1c, 0x00, 0x00 },   // )           
    { 0x00, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00 },   // *           
    { 0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00 },   // +           
    { 0x00, 0x00, 0x00, 0x00, 0xA0, 0x60, 0x00, 0x00 },   // ,           
    { 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00 },   // -           
    { 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00 },   // .           
    { 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00 },   // /           
    { 0x00, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00 },   // 0           
    { 0x00, 0x00, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00 },   // 1           
    { 0x00, 0x00, 0x42, 0x61, 0x51, 0x49, 0x46, 0x00 },   // 2           
    { 0x00, 0x00, 0x21, 0x41, 0x45, 0x4B, 0x31, 0x00 },   // 3           
    { 0x00, 0x00, 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00 },   // 4           
    { 0x00, 0x00, 0x27, 0x45, 0x45, 0x45, 0x39, 0x00 },   // 5           
    { 0x00, 0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00 },   // 6           
    { 0x00, 0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00 },   // 7           
    { 0x00, 0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00 },   // 8           
    { 0x00, 0x00, 0x06, 0x49, 0x49, 0x29, 0x1E, 0x00 },   // 9           
    { 0x00, 0x00, 0x00, 0x36, 0x36, 0x00, 0x00, 0x00 },   // :           
    { 0x00, 0x00, 0x00, 0x56, 0x36, 0x00, 0x00, 0x00 },   // ;           
    { 0x00, 0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00 },   // <           
    { 0x00, 0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00 },   // =           
    { 0x00, 0x00, 0x00, 0x41, 0x22, 0x14, 0x08, 0x00 },   // >           
    { 0x00, 0x00, 0x02, 0x01, 0x51, 0x09, 0x06, 0x00 },   // ?           
    { 0x00, 0x00, 0x32, 0x49, 0x59, 0x51, 0x3E, 0x00 },   // @           
    { 0x00, 0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C, 0x00 },   // A           
    { 0x00, 0x00, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00 },   // B           
    { 0x00, 0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00 },   // C           
    { 0x00, 0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00 },   // D           
    { 0x00, 0x00, 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00 },   // E           
    { 0x00, 0x00, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00 },   // F           
    { 0x00, 0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00 },   // G           
    { 0x00, 0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00 },   // H           
    { 0x00, 0x00, 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00 },   // I           
    { 0x00, 0x00, 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00 },   // J           
    { 0x00, 0x00, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00 },   // K           
    { 0x00, 0x00, 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00 },   // L           
    { 0x00, 0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00 },   // M           
    { 0x00, 0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00 },   // N           
    { 0x00, 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00 },   // O           
    { 0x00, 0x00, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00 },   // P           
    { 0x00, 0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00 },   // Q           
    { 0x00, 0x00, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x00 },   // R           
    { 0x00, 0x00, 0x46, 0x49, 0x49, 0x49, 0x31, 0x00 },   // S           
    { 0x00, 0x00, 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00 },   // T           
    { 0x00, 0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00 },   // U           
    { 0x00, 0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00 },   // V           
    { 0x00, 0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00 },   // W           
    { 0x00, 0x00, 0x63, 0x14, 0x08, 0x14, 0x63, 0x00 },   // X           
    { 0x00, 0x00, 0x07, 0x08, 0x70, 0x08, 0x07, 0x00 },   // Y           
    { 0x00, 0x00, 0x61, 0x51, 0x49, 0x45, 0x43, 0x00 },   // Z           
    { 0x00, 0x00, 0x00, 0x7F, 0x41, 0x41, 0x00, 0x00 },   // [           
    { 0x00, 0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55, 0x00 },   // 55          
    { 0x00, 0x00, 0x00, 0x41, 0x41, 0x7F, 0x00, 0x00 },   // ]           
    { 0x00, 0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00 },   // ^           
    { 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00 },   // _           
    { 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00 },   // '           
    { 0x00, 0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00 },   // a           
    { 0x00, 0x00, 0x7F, 0x48, 0x44, 0x44, 0x38, 0x00 },   // b           
    { 0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x20, 0x00 },   // c           
    { 0x00, 0x00, 0x38, 0x44, 0x44, 0x48, 0x7F, 0x00 },   // d           
    { 0x00, 0x00, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00 },   // e           
    { 0x00, 0x00, 0x08, 0x7E, 0x09, 0x01, 0x02, 0x00 },   // f           
    { 0x00, 0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C, 0x00 },   // g           
    { 0x00, 0x00, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00 },   // h           
    { 0x00, 0x00, 0x00, 0x44, 0x7D, 0x40, 0x00, 0x00 },   // i           
    { 0x00, 0x00, 0x40, 0x80, 0x84, 0x7D, 0x00, 0x00 },   // j           
    { 0x00, 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00 },   // k           
    { 0x00, 0x00, 0x00, 0x41, 0x7F, 0x40, 0x00, 0x00 },   // l           
    { 0x00, 0x00, 0x7C, 0x04, 0x18, 0x04, 0x78, 0x00 },   // m           
    { 0x00, 0x00, 0x7C, 0x08, 0x04, 0x04, 0x78, 0x00 },   // n           
    { 0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00 },   // o           
    { 0x00, 0x00, 0xFC, 0x24, 0x24, 0x24, 0x18, 0x00 },   // p           
    { 0x00, 0x00, 0x18, 0x24, 0x24, 0x18, 0xFC, 0x00 },   // q           
    { 0x00, 0x00, 0x7C, 0x08, 0x04, 0x04, 0x08, 0x00 },   // r           
    { 0x00, 0x00, 0x48, 0x54, 0x54, 0x54, 0x20, 0x00 },   // s           
    { 0x00, 0x00, 0x04, 0x3F, 0x44, 0x40, 0x20, 0x00 },   // t           
    { 0x00, 0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00 },   // u           
    { 0x00, 0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00 },   // v           
    { 0x00, 0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00 },   // w           
    { 0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00 },   // x           
    { 0x00, 0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C, 0x00 },   // y           
    { 0x00, 0x00, 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00 },   // z           
    { 0x00, 0x00, 0x00, 0x06, 0x09, 0x09, 0x06, 0x00 }    // horiz lines  
}; 

//setup for plasma
typedef struct
{
  unsigned char r;
  unsigned char g;
  unsigned char b;
} ColorRGB;

//a color with 3 components: h, s and v
typedef struct 
{
  unsigned char h;
  unsigned char s;
  unsigned char v;
} ColorHSV;

unsigned char plasma[SCREENSIZEX][SCREENSIZEY];
long paletteShift;

 
void setup() 
{
  Wire.begin(); // join i2c bus (address optional for master)  
  plasma_setup();   //plasma setup
}

void loop()
{
  //Plasma Morph for funky colour transitioning
  //plasma_morph(); 
  
  //Display Text for writing out scrolling messages
  /*
  for (int i = -7; i < 7; i++) {
    displayText('A', 0, 255, 80, i);
    delay(50);
  }
  */
}

//update display buffer using x,y,r,g,b format
void display(byte x, byte y, byte r, byte g, byte b) {
  byte p = (y*8)+x;   //convert from x,y to pixel number in array
  display_byte[0][p] = r;
  display_byte[1][p] = g;
  display_byte[2][p] = b;
}


//send display buffer to display 
void update_display(byte addr) {   
  BlinkM_sendBuffer(addr, 0, display_byte[0]);   
  BlinkM_sendBuffer(addr, 1, display_byte[1]);   
  BlinkM_sendBuffer(addr, 2, display_byte[2]);  
}


//send data via I2C to a client
//takes approx 192microseconds from leonardo --> colourduino for this transaction
static void BlinkM_sendBuffer(byte addr, byte col, byte* disp_data) {
  for (int i = 0; i < 4; i++) {
    Wire.beginTransmission(addr);
    Wire.write(START_OF_DATA);
    Wire.write(col);
    Wire.write(i);
    for (int j = 0; j < 16; j++) {
      Wire.write(disp_data[i*16+j]);
    }
    Wire.write(END_OF_DATA);
    Wire.endTransmission();
  }
}

//plasma convert
//Converts an HSV color to RGB color
void HSVtoRGB(void *vRGB, void *vHSV) 
{
  float r, g, b, h, s, v; //this function works with floats between 0 and 1
  float f, p, q, t;
  int i;
  ColorRGB *colorRGB=(ColorRGB *)vRGB;
  ColorHSV *colorHSV=(ColorHSV *)vHSV;

  h = (float)(colorHSV->h / 256.0);
  s = (float)(colorHSV->s / 256.0);
  v = (float)(colorHSV->v / 256.0);

  //if saturation is 0, the color is a shade of grey
  if(s == 0.0) {
    b = v;
    g = b;
    r = g;
  }
  //if saturation > 0, more complex calculations are needed
  else
  {
    h *= 6.0; //to bring hue to a number between 0 and 6, better for the calculations
    i = (int)(floor(h)); //e.g. 2.7 becomes 2 and 3.01 becomes 3 or 4.9999 becomes 4
    f = h - i;//the fractional part of h

    p = (float)(v * (1.0 - s));
    q = (float)(v * (1.0 - (s * f)));
    t = (float)(v * (1.0 - (s * (1.0 - f))));

    switch(i)
    {
      case 0: r=v; g=t; b=p; break;
      case 1: r=q; g=v; b=p; break;
      case 2: r=p; g=v; b=t; break;
      case 3: r=p; g=q; b=v; break;
      case 4: r=t; g=p; b=v; break;
      case 5: r=v; g=p; b=q; break;
      default: r = g = b = 0; break;
    }
  }
  colorRGB->r = (int)(r * 255.0);
  colorRGB->g = (int)(g * 255.0);
  colorRGB->b = (int)(b * 255.0);
}


unsigned int RGBtoINT(void *vRGB)
{
  ColorRGB *colorRGB=(ColorRGB *)vRGB;
  return (((unsigned int)colorRGB->r)<<16) + (((unsigned int)colorRGB->g)<<8) + (unsigned int)colorRGB->b;
}


float dist(float a, float b, float c, float d) 
{
  return sqrt((c-a)*(c-a)+(d-b)*(d-b));
}

void plasma_morph()
{
  unsigned char x,y;
  float value;
  ColorRGB colorRGB;
  ColorHSV colorHSV;
  for(x = 0; x <SCREENSIZEX; x++) {
    for(y = 0; y < SCREENSIZEY; y++) {
      value = sin(dist(x + paletteShift, y, 128.0, 128.0) / 8.0)
        + sin(dist(x, y, 64.0, 64.0) / 8.0)
        + sin(dist(x, y + paletteShift / 7, 192.0, 64) / 7.0)
        + sin(dist(x, y, 192.0, 100.0) / 8.0);
      colorHSV.h=(unsigned char)((value) * 128)&0xff;
      colorHSV.s=255; 
      colorHSV.v=255;
      HSVtoRGB(&colorRGB, &colorHSV);
      display(x, y, colorRGB.r, colorRGB.g, colorRGB.b);
    }
  }
  paletteShift++;
  update_display(DEST_I2C_ADDR);
}

 //plasma setup - start with morphing plasma, but allow going to color cycling if desired.
void plasma_setup()
{
  paletteShift=128000;
  unsigned char bcolor;
  for(unsigned char x = 0; x < SCREENSIZEX; x++) {
    for(unsigned char y = 0; y < SCREENSIZEY; y++)
    {
      //the plasma buffer is a sum of sines
      bcolor = (unsigned char)
      (
            128.0 + (128.0 * sin(x*8.0 / 16.0))
          + 128.0 + (128.0 * sin(y*8.0 / 16.0))
      ) / 2;
      plasma[x][y] = bcolor;
    }    
  }
}

void displayText(char chr, unsigned char R, unsigned char G, unsigned char B, char bias) {
  unsigned char x,y;
  unsigned char i,j,temp;
  unsigned char Char;
  unsigned char chrtemp[24] = {0};
  float value;
  ColorRGB colorRGB;
  if ((bias > 8) || (bias < -8)) {
    return;
  }
  Char = chr - 32;
  j = 8 - bias;
  for(i = 0;i< 8;i++)
  {
    chrtemp[j] = pgm_read_byte(&(font8_8[Char][i]));    
    j++;
  }  
  for(i = 0; i < 8; i++)
  {
    temp = chrtemp[i+8];
    for(j = 0; j < 8; j++)
    {
      if(temp & 0x80)
      {
        colorRGB.r = R;
        colorRGB.g = G;
        colorRGB.b = B;
        display(i, j, colorRGB.r, colorRGB.g, colorRGB.b);
      }
      else
      {
        colorRGB.r = 0;
        colorRGB.g = 0;
        colorRGB.b = 0;
        display(i, j, colorRGB.r, colorRGB.g, colorRGB.b);
      }
      temp = temp << 1;
    }
  }
  update_display(DEST_I2C_ADDR);
}

